# 第三阶段报告  

> ——programming-team-X-C-X

## 已实现的功能

本阶段由第二阶段已经实现的代码框架下发展而来。以下是目前实现功能概述。

### 游戏逻辑部分

第二阶段已经基本完成实现(如移动提示和棋子移动动画)，此处不再提及，详情可见第二阶段报告。

### 联机逻辑部分

1. 服务端和客户端正常连接通信。
2. 行棋合法性和胜负判断。服务端可正确进行游戏逻辑的处理。
3. 超时判断。服务端能进行超时判断，并可在服务端设置超时时长。
4. 客户端可点击认输按钮认输。
5. 客户端界面优化。进行游戏时，会展示当前的行棋信息: 用户名 当前行棋方 倒计时等。在结束时也会出现对应的结算信息窗口。
6. 再来一局的实现(大概)。结束时会自动发出离开信号，客户端点击再来一局后，会跳转到保存了上次用户信息的联机窗口，再次点击准备则再次向服务端发起连接请求。
7. AI可通过点击 **AI托管** 按钮实现 AI托管的随时开闭。



## 客户端: 类的关系与代码框架

客户端代码是在第二阶段的基础上进行的扩充。即在本地游戏的基础上增添了联机游戏模式。故以下只介绍增添的部分。

#### Online_MainWindow

> 继承自QMainWindow

这里实现了客户端向服务端发送请求和处理服务端响应的功能。

#### Online_View

> 继承自QMainWindow

这是游戏的核心显示界面，展示游戏和用户的信息以及处理用户的点击信息。

#### Online_end_dialog

>继承自QWidget

展示游戏结束后的界面。可选择**再来一局**或者**返回主菜单**。

## 服务端: 类的关系与代码框架

服务端代码简单实现了对客户端信息和游戏逻辑的处理。

#### MainWindow

> 继承自QMainWindow

这里实现了服务端监听端口，处理客户端信息的请求，以及相应游戏逻辑的处理。

#### 其他

> 对surakarta的游戏逻辑的包含

## 联网功能概述

其实本阶段任务主要是实现对收到的networkdata进行相对应的处理，比较繁琐但简单，故以下简要阐述一些网络信息处理的地方。

1. 客户端
   1. 点击准备按钮会发送连接请求，即类似`socket->send(NetworkData(OPCODE::READY_OP,"Team4", color ,"1"));`
   2. 收到reject_op时，会弹出警告框，需要重新连接。
   3. 用户点击完成行棋或者AI向服务端发出行棋请求，即                                                                                                                               ` socket->send(NetworkData(OPCODE::MOVE_OP,FormatPos(move.from),FormatPos(move.to),""));`其中*FormatPos()*实现棋子移动的坐标的规范化。
   4. 收到服务端的ready_op时，会对客户端用户信息进行初始化，即用户名，当前执棋颜色，超时时长等，并且尝试发起第一次行棋请求。
   5. 收到服务端的move_op时，会执行相应的move操作，并且在动画结束时尝试向服务端发起行棋请求。
   6. 收到服务端的end_op时，会跳转出结束窗口，并且向服务端发送leave_op。
2. 服务端
   1. 点击开始监听按钮会对指定端口进行监听。
   2. 收到客户端的ready_op时会自行对客户端的请求是否合法进行判断，非法则发送reject_op。合法则存储相关客户端的信息，且在有两个客户端时会向二者转发ready_op并等待客户端的move请求。
   3. 收到客户端的resign请求时，会判断是那一个客户端发出的，并向二者发出相应的end_op。
   4. 收到客户端的leave_op时，则会清空相关的客户端信息。

## 重点功能介绍

其实本阶段任务主要是实现对收到的networkdata进行相对应的处理，比较繁琐但简单，故以下重点阐述个人觉得比较关键的地方。

### 客户端 实现AI托管的随时开闭

我们规定了一个在settings中全局可见的IsAi的变量，通过点击相应按钮可以对该值进行修改，即实现AI的开关。

具体来说

​	当处于AI托管下时，我们会在收到服务端的**ready_op**时，让AI进行第一次move的计算并向服务端发出请求

​	之后通过信号和槽机制，实现动画结束时客户端的AI会再次计算并向服务端发起行棋请求。

`connect(Game->chessBoard,&ChessBoardWidget::animationFinished,this,[=](){
        ....
        if(IsAi) Game->computerMove();`

`   });`

### 服务端 超时判断的实现

开始 : 

1. 在发送完两个ready_op后开始第一次计时。

2. 在发送完两个move_op后开始新一轮的计时。

结束 :

	   1. 收到客户端的move请求，结束计时。
	   1. 收到客户端的离开或认输请求，结束计时。

### 细节优化

1. 实现在棋子移动未结束时无法进行点击。
2. 最后一步行棋结束时才会弹出结束窗口，而非收到end_op时直接弹出。



## 遇到的问题与解决

**客户端命令行调用的实现**

一开始实现时，客户端总是不会像对应的ip和port发送准备。后面发现是少了`this->socket->base()->waitForConnected(2000);`

**服务端超时判断和客户端游戏轮数更新的实现**

之前服务端的倒计时总是会快于客户端的显示，客户端的游戏轮数更新也并不正常。在Debug时发现问题出现在`connet`函数上，似乎如果多次连接同样的信号，那么在收到信号时对应的槽函数也会执行多次。在保证连接只出现一次后，问题迎刃而解。

## 小组分工

客户端和服务端的基本逻辑 : 肖俊皓 常皓飞

代码的整理与整合 : 	        常皓飞

AI的进一步完善 :  		    向禹

**本阶段的完成离不开小组中每一个人的努力。**

## 当前其他进度

1. 拓展任务
2. AI优化

   
