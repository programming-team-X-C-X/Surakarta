# **Surakarta第一阶段报告**  
### 一、规则判断

#### A.JudgeMove
1. 判断`NOT_PLAYER_TURN`：移动的棋子是否是当轮玩家  
2. 判断`OUT_OF_BOARD`：棋子是否在棋盘边界内  
3. 判断`NOT_PIECE`：移动的地方是否有棋子  
4. 判断`NOT_PLAYER_PIECE`：移动的棋子颜色是否正确  
5. 判断`LEGAL_NON_CAPTURE_MOVE`和`ILLIGAL_NON_CAPTURE_MOVE`：未吃子且移动合法为`LEGAL_NON_CAPTURE_MOVE`，否则为`ILLIGAL_NON_CAPTURE_MOVE`  
6. 判断`LEGAL_CAPTURE_MOVE`和`ILLIGAL_CAPTURE_MOVE`：
   * 取出可以吃子的环，遍历环上的每一个位置，记录在数组`line[4][3]`中，记下每个棋子的颜色和位置坐标
   * 理出所有相邻的直线  
   * 记相邻直线为P、Q，若P的最后一颗棋的颜色与Q的第一颗棋的颜色不一样，则可以双方向吃子，将合法吃子和被吃子的位置记录在数组`legal_capture_[][]`中；若P的最后一颗棋的颜色与Q的第一颗棋的颜色一样，且棋子位置也一样，则说明是同一颗棋子，进而判断P的最后一颗棋的颜色与Q的第二颗棋，若颜色不同，则可单方向吃子，同时还要判断判断P的倒数第二颗棋的颜色与Q的第一颗棋，若颜色不同，也可单方向吃子，记录在数组`legal_capture_[][]`中  
   * 将上述步骤循环环的个数次，处理出所有合法的吃子可能  
   * 将此次吃子与数组中所有合法吃子情况比对即可

#### B.	JudgeEnd
1. 判断`ILLIGAL_MOVE`：若一方移动非法，则另一方胜利  
2. 判断`CHECKMATE`：遍历棋盘，得到双方棋子个数，若一方棋子个数为1，且当轮为另一方的合法吃子，则另一方胜利  
3. 判断`STALEMATE`：若达到最大不吃子轮数，且当轮仍未能有合法吃子，则判断双方剩余棋子个数来确定赢家

### 二、AI实现
#### A．算法使用  
1. 构建所有可能的棋步：首先通过遍历棋盘上的所有位置，并检查每个位置的棋子颜色是否与当前玩家的颜色匹配，来找出当前玩家所有可能的棋步。对于每个合法的棋步，创建一个对应的 `SurakartaMove` 对象，并将其添加到 `moves` 向量中。同时，也在 `wins` 和 `plays` 向量中为每个棋步添加一个初始值为0的条目。
2. 模拟棋步并统计结果：在这个部分，我们对每个可能的棋步进行模拟，并记录每个棋步的结果。对于每个棋步，它都会复制当前的游戏状态，并在复制的棋盘上执行这个棋步。然后，它会检查这个棋步是否导致当前玩家获胜。如果是，那么这个棋步的 `wins` 计数就会增加。无论棋步的结果如何，该棋步的 `plays` 计数都会增加。
3. 选择最佳棋步：在所有的模拟完成后，代码将通过比较每个棋步的 `wins` 计数来选择最佳的棋步。具体来说，它会选择 `wins` 计数最高的那个棋步。如果有多个棋步的 `wins` 计数相同，那么它会选择第一个达到最高计数的棋步。  
4. 最后，函数会返回最佳的棋步。
#### B．些许优化
我们首先优先考虑能够吃掉对方棋子的移动。在模拟的过程中，我们优先选择那些能够立即吃掉对方棋子的移动。如果没有这样的移动，我们再进行随机选择。
#### C. 问题
仅仅是简单实现了MCTS，优化思路也比较简单，目前只是随机选择，无法保证胜率。
### 三、任务分工
思路分析：项晓清 李玉玺 刘雪琦  

规则判断代码实现：项晓清  

AI代码实现：李玉玺  

报告完成：项晓清 李玉玺


