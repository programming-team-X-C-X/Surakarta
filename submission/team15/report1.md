# 第一阶段报告

## 一、规则实现

### 1.judgemove

* 移动是否超出棋盘边界：将move.from坐标、move.to坐标与boardsize作比较。

* 判断是否操作非棋子的位置：判断move.from棋子颜色是否不是黑色也不是白色。

* 判断是否是合法玩家在操作：将当前玩家与实际玩家比较。

* 判断玩家是否正确移动己方棋子：将move.from的棋子颜色与玩家颜色相比较。

* 判断是否是合法的不吃子移动：移动范围在上下左右、左上、左下、右上、右下八个位置范围内且目标位置不能有棋子。

* 旋吃：我们首先确定起始位置是在哪个环上，为了避免不同环交叉位置的影响，在分类讨论时，我们选取了互不干扰的行或列。旋吃在一个环道上无非只有两条路，即顺时针和逆时针，为了提高代码的可重复性，我们为棋子的信息设置了坐标与移动方向（方向即direction，1代表向左，2代表向右，3代表向上，4代表向下）。在while循环中，只要没碰到目标棋子，循环就会模拟棋子移动遍历，在遇到旋的时候更改棋子位置与移动方向，并且将经过旋的次数times+1。如果遇到了非目标棋子同时非初始位置，就算遇到了障碍，此时flag+1。最后判断是否合法时，就要看times是否大于零，并且flag是否等于0，两项都满足才算合法。

* n!=6的情况：我们用for循环遍历环道的行或列即可实现。

  

### 2.judgeend

* 如果走出非法步，自动结束。

* 只剩一个棋子时，该棋子可以被对手吃，那么游戏结束。

* 未吃子轮数超过设置的最大轮数，再看哪方棋子多。

  

## 二、AI实现

使用蒙特卡洛树搜索（MCTS）算法，将博弈过程视作一棵决策树。树的节点是某个特定的棋盘局面，树的边表示一步 move

AI 具体思路：

对于某个局面，使用如下方案计算 move

* 将当前棋盘作为根节点

* MCTS Select 步骤：从根节点开始，寻找某一个未完全扩展的节点。未完成扩展的节点是指，其还有可能的子节点未建立。

* 一个节点的所有子节点，是通过当前节点的所有 legal moves 生成的。只要 legal_moves.size < children.size，就表示未完全扩展。

* 实现过程中为了让行棋更激进，如果有可能吃子的步骤，优先吃子。

* MCTS Expand 步骤：扩展出新的子节点。这对应着一个 legal move

* MCTS Simulate 步骤：用于判断 legal move 的质量。即，从子节点对应的局面开始，随机进行游戏，若玩家获胜，则给予 legal move 更高的 reward，反之减低。

* 具体的计算，使用了 UCB1 算法【原理、算法、优势、超参数之类的自己查资料吧】

* MCTS Back Propagate 步骤：从根节点开始到扩展的子节点这一路径上的子节点，都根据 Simulate 的 reward 更新节点（对应的 move）的 reward

* 反复进行上述 4 步骤。迭代越多计算越准确。实现的时候设置为 100。

最终的 move，是当前棋盘根节点的所有子节点中，reward 最高的子节点对应的 move

## 三、遇到的问题及解决方法

### 1.规则实现

思路其实并没有问题，只是代码中会有些小的手误写错了。并且在测试时并没有及时去更新助教的改动，没有先删除build再测试导致在这方面消耗很多时间。

### 2.AI实现

打分的规则不完善（minmax搜索最底层给棋盘打分）：参考了一些论文文献，在报告最后标注。

## 四、分工

* 规则实现：王粲然
* AI实现：陈青阳
* 实验报告：王粲然、杨昱文、陈青阳

> 刘璇，陶秋子，赵洪飞，等.计算机博弈苏拉卡尔塔棋的算法研究与改进[J].中文科技期刊数据库(全文版)自然科学,2018,[计算机博弈苏拉卡尔塔棋的算法研究与改进 - 道客巴巴 (doc88.com)](https://www.doc88.com/p-3009165882898.html)



