# 第三阶段报告

### （一）联网

#### server项目：

项目的代码主要有两部分：实现游戏的代码和实现信息传输的代码。

游戏部分的代码：游戏大体框架不做改动，将进行游戏所需的`move`，`judge_move`和`judge_end`函数放在了服务器的接收信号的函数中，便于在游戏中移动棋子。

信息传输部分的代码：包括基本的`networkerserver`类和`networkdata`类，用它俩来实现基本的网络通信功能。再根据通信协议完善server的附加功能（判断移动合法性、判断超时等）。

#### 客户端项目：

项目的代码有两部分：实现游戏的代码（游戏界面、客户端界面设计和进行游戏）和和实现信息

传输的代码。

游戏部分的代码：大体沿用上个阶段写成的本地对战的代码，主要改动了调用`move`部分的代码，通过`mousereleaseEvent`等函数获得点击的棋子的信息，使游戏正常进行。

信息传输部分的代码：包括基本的`networkclient`类和`networkdata`类。每运行一次项目就相当于开了一个客户端和一个游戏，二者一一对应，利用传输的信息让游戏正常进行。



### （二）游戏逻辑

除了让server来进行移动合法性判断、限时判断的改动以外，不同于获取点击位置来进行移动，我们接入了随机AI来实现托管。我们使用多线程，新写了一个AI的线程，即`AIThread`，在`client`中创了它的实例`MyAi`,使用`start()`函数让AI与主线程并行，并在`run()`函数的循环中用条件变量实现了线程的结束。在子线程中调用`QThread::sleep()`后是不会阻塞主线程的，这样就实现了随时启动或者结束AI托管。

### （三）遇到的困难

1.在主线程与子线程共享数据时，需要加上互斥锁防止数据的竞争导致最终结果的不确定性。

2.`sleep()`的使用，需要考虑到联网数据传输的时间以及动画的时间。

3.我么目前只实现了不吃子移动的动画，旋吃的动画首先需要我们确定可以走的路径，我修改了`JudgeMove()`函数，使得其给一个数组赋值，记录路径方向，最大的困难是如何让动画走出弧线。

4.刚开始不知道怎么让`server`获得`client`中的游戏信息，因为`data`无法传输棋盘信息等。所以我们试了几个办法（突发奇想），包括：在server中创造两个client对象，再在每个client中建一个游戏；往`server`中传`game`的指针等。解决方法：在`server`中再开了一个与客户端同步的游戏，利用客户端传来的`data`让`server`中的这个游戏同时在走，这样就能保证`server`和`client`中游戏信息是一样的了。

5.在前几个阶段，我们的游戏界面都是用代码画的（图省事），而不是用控件画的，没有办法展示出棋子的移动动画，最后还是把`ui`全部重做了一遍，把棋子都换成控件了才解决。



### （四）分工

* 杨昱文：完成前期联网代码的准备工作，完成服务器的代码，写报告
* 王粲然：完成客户端的代码，完成联网游戏的`ui`设计，接入AI，写报告
* 陈青阳：无

